Adversarial Attacks on Neural Network Policies Sandy Huangy, Nicolas Papernotz, Ian Goodfellowx, Yan Duanyx, Pieter Abbeelyx yUniversity of California, Berkeley, Department of Electrical Engineering and Computer Sciences zPennsylvania State University, School of Electrical Engineering and Computer Science xOpenAI Abstract Machine learning classiÔ¨Åers are known to be vulnerable to inputs maliciously constructed by adversaries to force misclassiÔ¨Åcation. Such adversarial examples have been extensively studied in the context of computer vision applications. In this work, we show adversarial attacks are also effective when targeting neural network policies in reinforcement learning. SpeciÔ¨Åcally, we show existing adversarial example crafting techniques can be used to signiÔ¨Åcantly degrade test-time performance of trained policies. Our threat model considers adversaries capable of introducing small perturbations to the raw input of the policy. We characterize the degree of vulnerability across tasks and training algorithms, for a subclass of adversarialexample attacks in white-box and black-box settings. Regardless of the learned task or training algorithm, we observe a signiÔ¨Åcant drop in performance, even with small adversarial perturbations that do not interfere with human perception. Videos are available at http://rll.berkeley.edu/adversarial . 1 Introduction Recent advances in deep learning and deep reinforcement learning (RL) have made it possible to learn end-to-end policies that map directly from raw inputs (e.g., images) to a distribution over actions to take. Deep RL algorithms have trained policies that achieve superhuman performance on Atari games  and Go , perform complex robotic manipulation skills , learn locomotion tasks , and drive in the real world . These policies are parametrized by neural networks, which have been shown to be vulnerable to adversarial attacks in supervised learning settings. For example, for convolutional neural networks trained to classify images, perturbations added to the input image can cause the network to classify the adversarial image incorrectly, while the two images remain essentially indistinguishable to humans . In this work, we investigate whether such adversarial examples affect neural network policies , which are trained with deep RL. We consider a fully trained policy at test time, and allow the adversary to make limited changes to the raw input perceived from the environment before it is passed to the policy. Unlike supervised learning applications, where a Ô¨Åxed dataset of training examples is processed during learning, in reinforcement learning these examples are gathered throughout the training process. In other words, the algorithm used to train a policy, and even the random initialization of the policy network‚Äôs weights, affects the states and actions encountered during training. Policies trained to do the same task could conceivably be signiÔ¨Åcantly different (e.g., in terms of the high-level features they extract from the raw input), depending on how they were initialized and trained. Thus, particular learning algorithms may result in policies more resistant to adversarial attacks. One could also imagine that the differences between supervised learning and reinforcement learning might prevent an adversary from mounting a successful attack in the black-box scenario, where the attacker does not have access to the target policy network.arXiv:1702.02284v1  [cs.LG]  8 Feb 2017action taken: down original input action taken: noop adversarial input  action taken: up original input action taken: down adversarial input  Figure 1: Two approaches for generating adversarial examples, applied to a policy trained using DQN  to play Pong. The dotted arrow starts from the ball and denotes the direction it is traveling in, and the green rectangle highlights the action that maximizes the Q-value, for the given input. In both cases, the policy chooses a good action given the original input, but the adversarial perturbation results in missing the ball and losing the point. Top: This adversarial example is computed using the fast gradient sign method (FGSM)  with an `1-norm constraint on the adversarial perturbation; the adversarial input is equivalent to the original input when converted to 8-bit image encodings, but is still able to harm performance. Bottom: FGSM with an `1-norm constraint; the optimal perturbation is to create a ‚Äúfake‚Äù ball lower than the position of the actual ball. Our main contribution is to characterize how the effectiveness of adversarial examples is impacted by two factors: the deep RL algorithm used to learn the policy, and whether the adversary has access to the policy network itself (white-box vs. black-box). We Ô¨Årst analyze three types of white-box attacks on four Atari games trained with three deep reinforcement learning algorithms (DQN , TRPO , and A3C ). We show that across the board, these trained policies are vulnerable to adversarial examples. However, policies trained with TRPO and A3C seem to be more resistant to adversarial attacks. Fig. 1 shows two examples of adversarial attacks on a Pong policy trained with DQN, each at a speciÔ¨Åc time step during test-time execution. Second, we explore black-box attacks on these same policies, where we assume the adversary has access to the training environment (e.g., the simulator) but not the random initialization of the target policy, and additionally may not know what the learning algorithm is. In the context of computer vision, Szegedy et al.  observed the transferability property : an adversarial example designed to be misclassiÔ¨Åed by one model is often misclassiÔ¨Åed by other models trained to solve the same task. We observe that the cross-dataset transferability property also holds in reinforcement learning applications, in the sense that an adversarial example designed to interfere with the operation of one policy interferes with the operation of another policy, so long as both policies have been trained to solve the same task. SpeciÔ¨Åcally, we observe that adversarial examples transfer between models trained using different trajectory rollouts and between models trained with different training algorithms. 22 Related Work Adversarial machine learning , and more generally the security and privacy of machine learning , encompasses a line of work that seeks to understand the behavior of models and learning algorithms in the presence of adversaries. Such malicious individuals can target machine learning systems either during learning by tampering with the training data , or during inference by manipulating inputs on which the model is making predictions . Among the perturbations crafted at test time, a class of adversarial inputs known as adversarial examples was introduced by . This Ô¨Årst demonstration of the vulnerability of ‚Äî then state-of-the-art ‚Äî architectures to perturbations indistinguishable to the human eye led to a series of follow-up work showing that perturbations could be produced with minimal computing resources  and/or with access to the model label predictions only (thus enabling black-box attacks) , and that these perturbations can also be applied to physical objects . Most work on adversarial examples so far has studied their effect on supervised learning algorithms. A recent technical report studied the scenario of an adversary interfering with the training of an agent, with the intent of preventing the agent from learning anything meaningful . Our work is the Ô¨Årst to study the ability of an adversary to interfere with the operation of an RL agent by presenting adversarial examples at test time. 3 Preliminaries In this section, we describe technical background on adversarial example crafting and deep reinforcement learning, which are used throughout the paper. 3.1 Adversarial Example Crafting with the Fast Gradient Sign Method Techniques for crafting adversarial examples generally focus on maximizing some measure of harm caused by an adversarial perturbation, constrained by some limit on the size of the perturbation intended to make it less noticeable to a human observer. A range of crafting techniques exist, allowing the attacker to choose an attack that makes the right tradeoff between computational cost and probability of success. For exploratory research purposes, it is common to use a computationally cheap method of generating adversarial perturbations, even if this reduces the attack success rate somewhat. We therefore use the Fast Gradient Sign Method (FGSM) , an existing method for efÔ¨Åciently generating adversarial examples in the context of computer vision classiÔ¨Åcation. The FGSM is fast because it makes a linear approximation of a deep model and solves the maximization problem analytically, in closed form. Despite this approximation, it is still able to reliably fool many classiÔ¨Åers for computer vision problems, because deep models often learn piece-wise linear functions with surprisingly large pieces. FGSM focuses on adversarial perturbations where each pixel of the input image is changed by no more than. Given a linear function g(x) =w>x, the optimal adversarial perturbation that satisÔ¨Åes kk1<is =sign(w); (1) since this perturbation maximizes the change in output for the adversarial example ~x,g(~x) = w>x+w>. Given an image classiÔ¨Åcation network with parameters and lossJ(;x;y ), wherexis an image andyis a distribution over all possible class labels, linearizing the loss function around the input x results in a perturbation of =sign(rxJ(;x;y )): (2) 3.2 Deep Reinforcement Learning Reinforcement learning algorithms train a policy to optimize the expected cumulative reward received over time. For a given state space Sand action spaceA, the policy may be a deterministic function mapping each state to an action: :S!A , or it may be a stochastic function mapping each state to a distribution over actions: :S! A, where Ais the probability simplex on A. Here, the state space may consist of images or low-dimensional state representations. We choose to 3representby a function parametrized by , for instance may be a weighting on features of the state . In the case of deep reinforcement learning, are the weights of a neural network. Over the past few years, a large number of algorithms for deep RL have been proposed, including deep Q-networks (DQN) , trust region policy optimization (TRPO) , and asynchronous advantage actor-critic (A3C) . We compare the effectiveness of adversarial examples on feed-forward policies trained with each of these three algorithms. 3.2.1 Deep Q-Networks Instead of modeling the policy directly, a DQN  approximately computes, for each state, the Q-values for the available actions to take in that state. The Q-value Q(s;a)for a statesand actiona is the expected cumulative discounted reward obtained by taking action ain states, and following the optimal policy thereafter. A DQN represents the Q-value function via a neural network trained to minimize the squared Bellman error, using a variant of Q-learning. As this is off-policy learning, it employs an-greedy exploration strategy. To reduce the variance of Q-learning updates, experience replay is used: samples are randomly drawn from a replay buffer (where all recent transitions are stored) so that they are not correlated due to time. The corresponding policy for a DQN is obtained by choosing the action with the maximum Q-value for each state, hence it is deterministic. 3.2.2 Trust Region Policy Optimization TRPO  is an on-policy batch learning algorithm. At each training iteration, whole-trajectory rollouts of a stochastic policy are used to calculate the update to the policy parameters , while controlling the change in the policy as measured by the KL divergence between the old and new policies. 3.2.3 Asynchronous Advantage Actor-Critic A3C  uses asynchronous gradient descent to speed up and stabilize learning of a stochastic policy. It is based on the actor-critic approach, where the actor is a neural network policy (ajs;) and the critic is an estimate of the value function V(s;v). During learning, small batches of onpolicy samples are used to update the policy. The correlation between samples is reduced due to asynchronous training, which stabilizes learning. 4 Adversarial Attacks In our work, we use FGSM both as a white-box attack to compute adversarial perturbations for a trained neural network policy whose architecture and parameters are available to the adversary, and as a black-box attack by computing gradients for a separately trained policy 0 to attackusing adversarial example transferability . 4.1 Applying FGSM to Policies FGSM requires calculating rxJ(;x;y ), the gradient of the cost function J(;x;y )with respect to the inputx. In reinforcement learning settings, we assume the output yis a weighting over possible actions (i.e., the policy is stochastic: :S! A). When computing adversarial perturbations with FGSM for a trained policy , we assume the action with the maximum weight in yis the optimal action to take: in other words, we assume the policy performs well at the task. Thus, J(;x;y )is the cross-entropy loss between yand the distribution that places all weight on the highest-weighted action iny.1 Of the three learning algorithms we consider, TRPO and A3C both train stochastic policies. However, DQN produces a deterministic policy, since it always selects the action that maximizes the computed Q-value. This is problematic because it results in a gradient rxJ(;x;y )of zero for almost all inputs x. Thus, when calculating J(;x;y )for policies trained with DQN, we deÔ¨Åne yas a softmax of the computed Q-values (with a temperature of 1). Note that we only do this for creating adversarial examples; during test-time execution, policies trained with DQN are still deterministic. 1Functionally, this is equivalent to a technique introduced in the context of image classiÔ¨Åcation, to generate adversarial examples without access to the true class label . 44.2 Choosing a Norm Constraint Letbe the adversarial perturbation. In certain situations, it may be desirable to change all input features by no more than a tiny amount (i.e., constrain the `1-norm of), or it may be better to change only a small number of input features (i.e., constrain the `1-norm of). Thus we consider variations of FGSM that restrict the `1and`2-norm of, as well as the original version of FGSM that restricts the `1-norm (Sec. 3.1). Linearizing the cost function J(;x;y )around the current input x, the optimal perturbation for each type of norm constraint is: =8 >>>< >>>:sign(rxJ(;x;y ))for constraintkk1 p drxJ(;x;y ) krxJ(;x;y )k2for constraintkk2k1dk2 maximally perturb highest-impact dimensions with budget d for constraintkk1k1dk1(3) wheredis the number of dimensions of input x. Note that the `2-norm and`1-norm constraints have adjusted to be the `2and`1-norm of the vector 1d, respectively, since that is the amount of perturbation under the `1-norm constraint. In addition, the optimal perturbation for the `1-norm constraint either maximizes or minimizes the feature value at dimensions iof the input, ordered by decreasing jrJ(;x;y )ij. For this norm, the adversary‚Äôs budget ‚Äî the total amount of perturbation the adversary is allowed to introduce in the input ‚Äî is d. 5 Experimental Evaluation We evaluate our adversarial attacks on four Atari 2600 games in the Arcade Learning Environment : Chopper Command, Pong, Seaquest, and Space Invaders. We choose these games to encompass a variety of interesting environments; for instance, Chopper Command and Space Invaders include multiple enemies. 5.1 Experimental Setup We trained each game with three deep reinforcement learning algorithms: A3C , TRPO , and DQN . For DQN, we use the same pre-processing and neural network architecture as in  (Appendix A). We also use this architecture for the stochastic policies trained by A3C and TRPO. SpeciÔ¨Åcally, the input to the neural network policy is a concatenation of the last 4 images, converted from RGB to luminance (Y) and resized to 8484. Luminance values are rescaled to be from 0 to 1. The output of the policy is a distribution over possible actions. For each game and training algorithm, we train Ô¨Åve policies starting from different random initializations. For our experiments, we focus on the top-performing trained policies, which we deÔ¨Åne as all policies that perform within 80% of the maximum score for the last ten training iterations. We cap the number of policies at three for each game and training algorithm. Certain combinations (e.g., Seaquest with A3C) had only one policy meet these requirements. In order to reduce the variance of our experimental results, the average return for each result reported is the average cumulative reward across ten rollouts of the target policy, without discounting rewards. 5.2 Vulnerability to White-Box Attacks First, we are interested in how vulnerable neural network policies are to white-box adversarialexample attacks, and how this is affected by the type of adversarial perturbation and by how the policy is trained. If these attacks are effective, even small adversarial perturbations (i.e., small for FGSM) will be able to signiÔ¨Åcantly lower the performance of the target trained network, as observed in  for image classiÔ¨Åers. We evaluate multiple settings of across all four games and three training algorithms, for the three types of norm-constraints for FGSM. 50.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon101000200030004000500060007000Average/uni00A0ReturnChopper/uni00A0Command,/uni00A0A3C 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon130 20 10 0102030Average/uni00A0ReturnPong,/uni00A0A3C 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon1050010001500200025003000Average/uni00A0ReturnSeaquest,/uni00A0A3C 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon102004006008001000Average/uni00A0ReturnSpace/uni00A0Invaders,/uni00A0A3C 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon1010002000300040005000600070008000Average/uni00A0ReturnChopper/uni00A0Command,/uni00A0TRPO 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon130 20 10 0102030Average/uni00A0ReturnPong,/uni00A0TRPO 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon120030040050060070080090010001100Average/uni00A0ReturnSeaquest,/uni00A0TRPO 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon10200400600800100012001400Average/uni00A0ReturnSpace/uni00A0Invaders,/uni00A0TRPO 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon14006008001000120014001600180020002200Average/uni00A0ReturnChopper/uni00A0Command,/uni00A0DQN 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon125 20 15 10 5 05101520Average/uni00A0ReturnPong,/uni00A0DQN 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon105001000150020002500Average/uni00A0ReturnSeaquest,/uni00A0DQN 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon10100200300400500600700800Average/uni00A0ReturnSpace/uni00A0Invaders,/uni00A0DQNFigure 2: Comparison of the effectiveness of `1,`2, and`1FGSM adversaries on four Atari games trained with three learning algorithms. The average return is taken across ten trajectories. Constraint on FGSM perturbation: `1-norm`2-norm`1-norm 5.2.1 Observations We Ô¨Ånd that regardless of which game the policy is trained for or how it is trained, it is indeed possible to signiÔ¨Åcantly decrease the policy‚Äôs performance through introducing relatively small perturbations in the inputs (Fig. 2). Notably, in many cases an `1-norm FGSM adversary with = 0:001decreases the agent‚Äôs performance by 50% or more; when converted to 8-bit image encodings, these adversarial inputs are indistinguishable from the original inputs. In cases where it is not essential for changes to be imperceptible, using an `1-norm adversary may be a better choice: given the same ,`1-norm adversaries are able to achieve the most signiÔ¨Åcant decreases in agent performance. They are able to sharply decrease the agent‚Äôs performance just by changing a few pixels (by large amounts). We see that policies trained with A3C, TRPO, and DQN are all susceptible to adversarial inputs. Interestingly, policies trained with DQN are more susceptible, especially to `1-norm FGSM perturbations on Pong, Seaquest, and Space Invaders. 5.3 Vulnerability to Black-Box Attacks In practice, it is often the case that an adversary does not have complete access to the neural network of the target policy . This threat model is frequently referred to as a black-box scenario. We investigate how vulnerable neural network policies are to black-box attacks of the following two variants: 1.The adversary has access to the training environment and knowledge of the training algorithm and hyperparameters. It knows the neural network architecture of the target policy network, but not its random initialization. We will refer to this as transferability across policies. 2.The adversary additionally has no knowledge of the training algorithm or hyperparameters. We will refer to this as transferability across algorithms. 60.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon101000200030004000500060007000Average/uni00A0ReturnChopper/uni00A0Command,/uni00A0A3C,/uni00A0/lscript‚àû/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon130 20 10 0102030Average/uni00A0ReturnPong,/uni00A0A3C,/uni00A0/lscript‚àû/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon1050010001500200025003000Average/uni00A0ReturnSeaquest,/uni00A0A3C,/uni00A0/lscript‚àû/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon11002003004005006007008009001000Average/uni00A0ReturnSpace/uni00A0Invaders,/uni00A0A3C,/uni00A0/lscript‚àû/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon10100020003000400050006000Average/uni00A0ReturnChopper/uni00A0Command,/uni00A0A3C,/uni00A0/lscript1/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon130 20 10 0102030Average/uni00A0ReturnPong,/uni00A0A3C,/uni00A0/lscript1/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon1050010001500200025003000Average/uni00A0ReturnSeaquest,/uni00A0A3C,/uni00A0/lscript1/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon102004006008001000Average/uni00A0ReturnSpace/uni00A0Invaders,/uni00A0A3C,/uni00A0/lscript1/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon1010002000300040005000600070008000Average/uni00A0ReturnChopper/uni00A0Command,/uni00A0A3C,/uni00A0/lscript2/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon130 20 10 0102030Average/uni00A0ReturnPong,/uni00A0A3C,/uni00A0/lscript2/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon1050010001500200025003000Average/uni00A0ReturnSeaquest,/uni00A0A3C,/uni00A0/lscript2/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon11002003004005006007008009001000Average/uni00A0ReturnSpace/uni00A0Invaders,/uni00A0A3C,/uni00A0/lscript2/uni00A0normFigure 3: Transferability of adversarial inputs for policies trained with A3C. Type of transfer: algorithm policy none 5.3.1 Transferability Across Policies To explore transferability of adversarial examples across policies, we generate adversarial perturbations for the target policy using one of the other top-performing policies trained with the same algorithm for the same task. We test all adversary-target combinations of top-performing policies trained with the same algorithm, for each combination of task, learning algorithm, and type of adversary. 5.3.2 Transferability Across Training Algorithms To explore transferability of adversarial examples across training algorithms, we generate adversarial perturbations for the target policy using one of the top-performing policies trained with a different algorithm. Similarly, we test all adversary-target combinations of top-performing policies trained with different algorithms, for each combination of task and type of adversary. 5.3.3 Observations As one might expect, we Ô¨Ånd that the less the adversary knows about the target policy, the less effective the adversarial examples are (Fig. 3, 4, 5). Transferability across algorithms is less effective at decreasing agent performance than transferability across policies, which is less effective than when the adversary does not need to rely on transferability (i.e., the adversary has full access to the target policy network). However, for most games, transferability across algorithms is still able to signiÔ¨Åcantly decrease the agent‚Äôs performance, especially for larger values of . Notably for`1-norm adversaries, transferability across algorithms is nearly as effective as no transferability, for most game and algorithm combinations. 6 Discussion and Future Work This direction of work has signiÔ¨Åcant implications for both online and real-world deployment of neural network policies. Our experiments show it is fairly easy to confuse such policies with computationally-efÔ¨Åcient adversarial examples, even in black-box scenarios. Based on , it is possible that these adversarial perturbations could be applied to objects in the real world, for 70.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon1010002000300040005000600070008000Average/uni00A0ReturnChopper/uni00A0Command,/uni00A0TRPO,/uni00A0/lscript‚àû/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon130 20 10 0102030Average/uni00A0ReturnPong,/uni00A0TRPO,/uni00A0/lscript‚àû/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon130040050060070080090010001100Average/uni00A0ReturnSeaquest,/uni00A0TRPO,/uni00A0/lscript‚àû/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon1200400600800100012001400Average/uni00A0ReturnSpace/uni00A0Invaders,/uni00A0TRPO,/uni00A0/lscript‚àû/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon1010002000300040005000600070008000Average/uni00A0ReturnChopper/uni00A0Command,/uni00A0TRPO,/uni00A0/lscript1/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon130 20 10 0102030Average/uni00A0ReturnPong,/uni00A0TRPO,/uni00A0/lscript1/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon12004006008001000Average/uni00A0ReturnSeaquest,/uni00A0TRPO,/uni00A0/lscript1/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon10200400600800100012001400Average/uni00A0ReturnSpace/uni00A0Invaders,/uni00A0TRPO,/uni00A0/lscript1/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon110002000300040005000600070008000Average/uni00A0ReturnChopper/uni00A0Command,/uni00A0TRPO,/uni00A0/lscript2/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon130 20 10 0102030Average/uni00A0ReturnPong,/uni00A0TRPO,/uni00A0/lscript2/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon120030040050060070080090010001100Average/uni00A0ReturnSeaquest,/uni00A0TRPO,/uni00A0/lscript2/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon10200400600800100012001400Average/uni00A0ReturnSpace/uni00A0Invaders,/uni00A0TRPO,/uni00A0/lscript2/uni00A0normFigure 4: Transferability of adversarial inputs for policies trained with TRPO. Type of transfer: algorithm policy none 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon14006008001000120014001600180020002200Average/uni00A0ReturnChopper/uni00A0Command,/uni00A0DQN,/uni00A0/lscript‚àû/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon125 20 15 10 5 05101520Average/uni00A0ReturnPong,/uni00A0DQN,/uni00A0/lscript‚àû/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon105001000150020002500Average/uni00A0ReturnSeaquest,/uni00A0DQN,/uni00A0/lscript‚àû/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon10100200300400500600700800Average/uni00A0ReturnSpace/uni00A0Invaders,/uni00A0DQN,/uni00A0/lscript‚àû/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon14006008001000120014001600180020002200Average/uni00A0ReturnChopper/uni00A0Command,/uni00A0DQN,/uni00A0/lscript1/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon125 20 15 10 5 05101520Average/uni00A0ReturnPong,/uni00A0DQN,/uni00A0/lscript1/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon105001000150020002500Average/uni00A0ReturnSeaquest,/uni00A0DQN,/uni00A0/lscript1/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon10100200300400500600700Average/uni00A0ReturnSpace/uni00A0Invaders,/uni00A0DQN,/uni00A0/lscript1/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon16008001000120014001600180020002200Average/uni00A0ReturnChopper/uni00A0Command,/uni00A0DQN,/uni00A0/lscript2/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon125 20 15 10 5 05101520Average/uni00A0ReturnPong,/uni00A0DQN,/uni00A0/lscript2/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon105001000150020002500Average/uni00A0ReturnSeaquest,/uni00A0DQN,/uni00A0/lscript2/uni00A0norm 0.000 0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 /epsilon10100200300400500600700Average/uni00A0ReturnSpace/uni00A0Invaders,/uni00A0DQN,/uni00A0/lscript2/uni00A0norm Figure 5: Transferability of adversarial inputs for policies trained with DQN. Type of transfer: algorithm policy none example adding strategically-placed paint to the surface of a road to confuse an autonomous car‚Äôs lane-following policy. Thus, an important direction of future work is developing defenses against adversarial attacks. This could involve adding adversarially-perturbed examples during training time (as in ), or it could involve detecting adversarial input at test time, to be able to deal with it appropriately. 