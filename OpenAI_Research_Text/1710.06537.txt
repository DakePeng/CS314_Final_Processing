Sim-to-Real Transfer of Robotic Control with Dynamics Randomization Xue Bin Peng1;2, Marcin Andrychowicz1, Wojciech Zaremba1, and Pieter Abbeel1;2 Abstract ‚Äî Simulations are attractive environments for training agents as they provide an abundant source of data and alleviate certain safety concerns during the training process. But the behaviours developed by agents in simulation are often speciÔ¨Åc to the characteristics of the simulator. Due to modeling error, strategies that are successful in simulation may not transfer to their real world counterparts. In this paper, we demonstrate a simple method to bridge this ‚Äúreality gap‚Äù. By randomizing the dynamics of the simulator during training, we are able to develop policies that are capable of adapting to very different dynamics, including ones that differ signiÔ¨Åcantly from the dynamics on which the policies were trained. This adaptivity enables the policies to generalize to the dynamics of the real world without any training on the physical system. Our approach is demonstrated on an object pushing task using a robotic arm. Despite being trained exclusively in simulation, our policies are able to maintain a similar level of performance when deployed on a real robot, reliably moving an object to a desired location from random initial conÔ¨Ågurations. We explore the impact of various design decisions and show that the resulting policies are robust to signiÔ¨Åcant calibration error. I. INTRODUCTION Deep reinforcement learning (DeepRL) has been shown to be an effective framework for solving a rich repertoire of complex control problems. In simulated domains, agents have been developed to perform a diverse array of challenging tasks , , . Unfortunately, many of the capabilities demonstrated by simulated agents have often not been realized by their physical counterparts. Many of the modern DeepRL algorithms, which have spurred recent breakthroughs, pose high sample complexities, therefore often precluding their direct application to physical systems. In addition to sample complexity, deploying RL algorithms in the real world also raises a number of safety concerns both for the agent and its surroundings. Since exploration is a key component of the learning process, an agent can at times perform actions that endanger itself or its environment. Training agents in simulation is a promising approach that circumvents some of these obstacles. However, transferring policies from simulation to the real world entails challenges in bridging the ‚Äùreality gap‚Äù, the mismatch between the simulated and real world environments. Narrowing this gap has been a subject of intense interest in robotics, as it offers the potential of applying powerful algorithms that have so far been relegated to simulated domains. While signiÔ¨Åcant efforts have been devoted to building higher Ô¨Ådelity simulators, we show that dynamics randomization using low Ô¨Ådelity simulations can also be an effective 1OpenAI 2UC Berkeley, Department of Electrical Engineering and Computer Science Fig. 1. A recurrent neural network policy trained for a pushing task in simulation is deployed directly on a Fetch Robotics arm. The red marker indicates the target location for the puck. approach to develop policies that can be transferred directly to the real world. The effectiveness of our approach is demonstrated on an object pushing task, where a policy trained exclusively in simulation is able to successfully perform the task with a real robot without additional training on the physical system. II. RELATED WORK Recent years have seen the application of deep reinforcement learning to a growing repertoire of control problems. The framework has enabled simulated agents to develop highly dynamic motor skills , , , . But due to the high sample complexity of RL algorithms and other physical limitations, many of the capabilities demonstrated in simulation have yet to be replicated in the physical world. Guided Policy Search (GPS)  represents one of the few algorithms capable of training policies directly on a real robot. By leveraging trajectory optimization with learned linear dynamics models, the method is able to develop complex manipulation skills with relatively few interactions with the environment. The method has also been extended to learning vision-based manipulation policies . Researchers have also explored parallelizing training across multiple robots . Nonetheless, successful examples of training policies directly on physical robots have so far been demonstrated only on relatively restrictive domains. A. Domain Adaptation The problem of transferring control policies from simulation to the real world can be viewed as an instance of domain adaptation, where a model trained in a source domain is transfered to a new target domain. One of the key assumptions behind these methods is that the different domains share common characteristics such that representations and behaviours learned in one will prove useful for the other. Learning invariant features has emerged as a promising approach of taking advantage of these commonalities , . Tzeng et al.  and Gupta et al.  explored using pairwise constraints to encourage networks to learn similar embeddings for samples from different domains that arearXiv:1710.06537v3  [cs.RO]  3 Mar 2018labeled as being similar. Daftry et al.  applied a similar approach to transfer policies for controlling aerial vehicles to different environments and vehicle models. In the context of RL, adversarial losses have been used to transfer policies between different simulated domains, by encouraging agents to adopt similar behaviours across the various environments . Alternatively, progressive networks have also been used to transfer policies for a robotic arm from simulation to the real world . By reusing features learned in simulation, their method was able to signiÔ¨Åcantly reduce the amount of data needed from the physical system. Christiano et al.  transfered policies from simulation to a real robot by training an inverse-dynamics model from real world data. While promising, these methods nonetheless still require data from the target domain during training. B. Domain Randomization Domain randomization is a complementary class of techniques for adaptation that is particularly well suited for simulation. With domain randomization, discrepancies between the source and target domains are modeled as variability in the source domain. Randomization in the visual domain has been used to directly transfer vision-based policies from simulation to the real world without requiring real images during training , . Sadeghi and Levine  trained vision-based controllers for a quadrotor using only synthetically rendered scenes, and Tobin et al.  demonstrated transferring image-based object detectors. Unlike previous methods, which sought to bridge the reality gap with high Ô¨Ådelity rendering , their systems used only low Ô¨Ådelity rendering and modeled differences in visual appearance by randomizing scene properties such as lighting, textures, and camera placement. In addition to randomizing the visual features of a simulation, randomized dynamics have also been used to develop controllers that are robust to uncertainty in the dynamics of the system. Mordatch et al.  used a trajectory optimizer to plan across an ensemble of dynamics models, to produce robust trajectories that are then executed on a real robot. Their method allowed a Darwin robot to perform a variety of locomotion skills. But due to the cost of the trajectory optimization step, the planning is performed ofÔ¨Çine. Other methods have also been proposed to develop robust policies through adversarial training schemes , . Yu et al.  trained a system identiÔ¨Åcation module to explicitly predict parameters of interest, such as mass and friction. The predicted parameters are then provided as input to a policy to compute the appropriate controls. While the results are encouraging, these methods have so far only been demonstrated on transfer between different simulators. The work most reminiscent to our proposed method is that of Antonova et al. , where randomized dynamics was used to transfer manipulation policies from simulation to the real world. By randomizing physical parameters such as friction and latency, they were able to train policies in simulation for pivoting objects held by a gripper, and later transfer the policies directly to a Baxter robot without requiring additional Ô¨Åne-tuning on the physical system. Howevertheir policies were modeled using memoryless feedforward networks, and while the policies developed robust strategies, the lack of internal state limits the feedforward policies‚Äô ability to adapt to mismatch between the simulated and real environment. We show that memory-based policies are able to cope with greater variability during training and also better generalize to the dynamics of the real world. Unlike previous methods which often require meticulous calibration of the simulation to closely conform to the physical system, our policies are able to adapt to signiÔ¨Åcant calibration error. C. Non-prehensile Manipulation Pushing, a form of non-prehensile manipulation, is an effective strategy for positioning and orienting objects that are too large or heavy to be grasped . Though pushing has attracted much interest from the robotics community , , , it remains a challenging skill for robots to adopt. Part of the difÔ¨Åculty stems from accurately modeling the complex contact dynamics between surfaces. Characteristics such as friction can vary signiÔ¨Åcantly across the surface of an object, and the resulting motions can be highly sensitive to the initial conÔ¨Åguration of the contact surfaces . Models have been proposed to facilitate planning algorithms , , , but they tend to rely on simplifying assumptions that are often violated in practice. More recently, deep learning methods have been applied to train predictive models for pushing . While data-driven methods overcome some of the modeling challenges faced by previous frameworks, they require a large corpus of real world data during training. Such a dataset can be costly to collect, and may become prohibitive for more complex tasks. Clavera et al. demonstrated transferring pushing policies trained in simulation to a real PR2 . Their approach took advantage of shaped reward functions and careful calibration to ensure that the behaviour of the simulation conforms to that of the physical system. In contrast, we will show that adaptive policies can be trained exclusively in simulation and using only sparse rewards. The resulting policies are able accommodate large calibration errors when deployed on a real robot and also generalize to variability in the dynamics of the physical system. III. BACKGROUND In this section we will provide a review of the RL framework and notation used in the following sections. We consider a standard RL problem where an agent interacts with an environment according to a policy in order to maximize a reward. The state of the environment at timestep tis denoted by st2S. For simplicity, we assume that the state is fully observable. A policy (ajs)deÔ¨Ånes a distribution over the action space Agiven a particular state s, where each query to the policy samples an action afrom the conditional distribution. The reward function r:SA! Rprovides a scalar signal that reÔ¨Çects the desirability of performing an action at a given state. For convenience, we denotert=r(st;at). The goal of the agent is to maximizethe multi-step return Rt=PT t0=t t0 trt0, where 2[0;1] is a discount factor and Tis the horizon of each episode. The objective during learning is to Ô¨Ånd an optimal policy that maximize the expected return of the agent J() = arg max J() If each episode starts in a Ô¨Åxed initial state, expected return can be rewritten as the expected return starting at the Ô¨Årst step J() =E[R0j] =Ep(j)"T 1X t=0r(st;at)# wherep(j)represents the likelihood of a trajectory = (s0;a0;s1;:::;aT 1;sT)under the policy , p(j) =p(s0)T 1Y t=0p(st+1jst;at)(st;at) with the state transition model p(st+1jst;at)being determined by the dynamics of the environment. The dynamics is therefore of crucial importance, as it determines the consequences of the agent‚Äôs actions, as well as the behaviours that can be realized. A. Policy Gradient Methods For a parametric policy with parameters , the objective is to Ô¨Ånd the optimal parameters that maximizes the expected return = arg maxJ(). Policy gradient methods  is a popular class of algorithms for learning parametric policies, where an estimate of the gradient of the objective OJ()is used to perform gradient ascent to maximize the expected return. While the previous deÔ¨Ånition of a policy is suitable for tasks where the goal is common across all episodes, it can be generalized to tasks where an agent is presented with a different goal every episode by constructing a universal policy . A universal policy is a simple extension where the goal g2Gis provided as an additional input to the policy (ajs;g). The reward is then also dispensed according to the goal r(st;at;g). In our framework, a random goal will be sampled at the start of each episode, and held Ô¨Åxed over the course the episode. For the pushing task, the goal speciÔ¨Åes the target location for an object. B. Hindsight Experience Replay During training, RL algorithms often beneÔ¨Åt from carefully shaped reward functions that help guide the agent towards fulÔ¨Ålling the overall objective of a task. But designing a reward function can be challenging for more complex tasks, and may bias the policy towards adopting less optimal behaviours. An alternative is to use a binary reward r(s;g) that only indicates if a goal is satisÔ¨Åed in a given state, r(s;g) =( 0; ifgis satisÔ¨Åed in s  1;otherwiseLearning from a sparse binary reward is known to be challenging for most modern RL algorithms. We will therefore leverage a recent innovation, Hindsight Experience Relay (HER) , to train policies using sparse rewards. Consider an episode with trajectory 2(s0;a0;:::;aT 1;sT), where the goalgwas not satisÔ¨Åed over the course the trajectory. Since the goal was not satisÔ¨Åed, the reward will be  1 at every timestep, therefore providing the agent with little information on how to adjust its actions to procure more rewards. But suppose that we are provided with a mapping m:S!G, that maps a state to the corresponding goal satisÔ¨Åed in the given state. For example, m(sT) =g0 represents the goal that is satisÔ¨Åed in the Ô¨Ånal state of the trajectory. Once a new goal has been determined, rewards can be recomputed for the original trajectory under the new goal g0. While the trajectory was unsuccessful under the original goal, it becomes a successful trajectory under the new goal. Therefore, the rewards computed with respect to g0will not be 1for every timestep. By replaying past experiences with HER, the agent can be trained with more successful examples than is available in the original recorded trajectories. So far, we have only considered replaying goals from the Ô¨Ånal state of a trajectory. But HER is also amenable to other replay strategies, and we refer interested readers to the original paper  for more details. IV. METHOD Our objective is to train policies that can perform a task under the dynamics of the real world p(st+1jst;at). Since sampling from the real world dynamics can be prohibitive, we instead train a policy using an approximate dynamics model ^p(st+1jst;at)p(st+1jst;at)that is easier to sample from. For all of our experiments, ^passumes the form of a physics simulation. Due to modeling and other forms of calibration error, behaviours that successfully accomplish a task in simulation may not be successful once deployed in the real world. Furthermore, it has been observed that DeepRL policies are prone to exploiting idiosyncrasies of the simulator to realize behaviours that are infeasible in the real world , . Therefore, instead of training a policy under one particular dynamics model, we train a policy that can perform a task under a variety of different dynamics models. First we introduce a set of dynamics parameters that parameterizes the dynamics of the simulation ^p(st+1jst;at;). The objective is then modiÔ¨Åed to maximize the expected return across a distribution of dynamics models , E " Ep(j;)"T 1X t=0r(st;at)## By training policies to adapt to variability in the dynamics of the environment, the resulting policy might then better generalize to the dynamics of real world. A. Tasks Our experiments are conducted on a puck pushing task using a 7-DOF Fetch Robotics arm. Images of the real robotFig. 2. Our experiments are conducted on a 7-DOF Fetch Robotics arm. Left: Real robot. Right: Simulated MuJoCo model. and simulated model is available in Figure 2. The goal gfor each episode speciÔ¨Åes a random target position on the table that the puck should be moved to. The reward is binary with rt= 0 if the puck is within a given distance of the target, andrt= 1otherwise. At the start of each episode, the arm is initialized to a default pose and the initial location of the puck is randomly placed within a Ô¨Åxed bound on the table. B. State and Action The state is represented using the joint positions and velocities of the arm, the position of the gripper, as well as the puck‚Äôs position, orientation, linear and angular velocities. The combined features result in a 52D state space. Actions from the policy specify target joint angles for a position controller. Target angles are speciÔ¨Åed as relative offsets from the current joint rotations. This yields a 7D action space. C. Dynamics Randomization During training, rollouts are organized into episodes of a Ô¨Åxed length. At the start of each episode, a random set of dynamics parameters are sampled according to and held Ô¨Åxed for the duration of the episode. The parameters which we randomize include: Mass of each link in the robot‚Äôs body Damping of each joint Mass, friction, and damping of the puck Height of the table Gains for the position controller Timestep between actions Observation noise which results in a total of 95 randomized parameters. The timestep between actions speciÔ¨Åes the amount of time an action is applied before the policy is queried again to sample a new action. This serves as a simple model of the latency exhibited by the physical controller. The observation noise models uncertainty in the sensors and is implemented as independent Gaussian noise applied to each state feature. While parameters such as mass and damping are constant over the course of an episode, the action timestep and the observation noise varies randomly each timestep. D. Adaptive Policy Manipulation tasks, such as pushing, have a strong dependency on the physical properties of the system (e.g. mass,friction, and characteristics of the actuators). In order to determine the appropriate actions, a policy requires some means of inferring the underlying dynamics of its environment. While the dynamics parameters are readily available in simulation, the same does not hold once a policy has been deployed in the real world. In the absence of direct knowledge of the parameters, the dynamics can be inferred from a history of past states and actions. System identiÔ¨Åcation using a history of past trajectories has been previously explored by Yu et al. . Their system incorporates an online system identiÔ¨Åcation module (st;ht) = ^, which utilizes a history of past states and actions ht= [at 1;st 1;at 2;st 2;:::]to predict the dynamics parameters . The predicted parameters are then used as inputs to a universal policy that samples an action according to the current state and inferred dynamics (atjst;^). However, this decomposition requires identifying the dynamics parameters of interest to be predicted at runtime, which may be difÔ¨Åcult for more complex systems. Constructing such a set of parameters necessarily requires some structural assumptions about the dynamics of a system, which may not hold in the real world. Alternatively, SysID can be implicitly embedded into a policy by using a recurrent model(atjst;zt;g), where the internal memory zt=z(ht) acts as a summary of past states and actions, thereby providing a mechanism with which the policy can use to infer the dynamics of the system. This model can then be trained end-to-end and the representation of the internal memory can be learned without requiring manual identiÔ¨Åcation of a set of dynamics parameters to be inferred at runtime. E. Recurrent Deterministic Policy Gradient Since HER augments the original training data recorded from rollouts of the policy with additional data generated from replayed goals, it requires off-policy learning. Deep Deterministic Policy Gradient (DDPG)  is a popular offpolicy algorithm for continuous control. Its extension to recurrent policies, Recurrent Deterministic Policy Gradient (RDPG) , provides a method to train recurrent policies with off-policy data. To apply RDPG, we denote a deterministic policy as (st;zt;g) =at. In additional to the policy, we will also model a recurrent universal value function asQ(st;at;yt;g;), whereyt=y(ht)is the value function‚Äôs internal memory. Since the value function is used only during training and the dynamics parameters of the simulator are known, is provided as an additional input to the value function but not to the policy. We will refer to a value function with knowledge of the dynamics parameters as an omniscient critic . This follows the approach of , , where additional information is provided to the value function during training in order to reduce the variance of the policy gradients and allow the value function to provide more meaningful feedback for improving the policy. Algorithm 1 summarizes the training procedure, where Mrepresents a replay buffer , and and'are the parameters for the policy and value function respectively. We also incorporate target networks , but they are excluded for brevity.Algorithm 1 Dynamics Randomization with HER and RDPG 1: random weights 2:' random weights 3:while not done do 4:ggsample goal 5:sample dynamics 6: Generate rollout = (s0;a0;:::;sT)with dynamics  7: foreachst;atindo 8:rt r(st;g) 9: end for 10: Store (;frtg;g;)inM 11: Sample episode (;frtg;g;)fromM 12: with probabilityk 13:g replay new goal with HER 14:rt r(st;g)for eacht 15: endwith 16: foreachtdo 17: Compute memories ztandyt 18: ^at+1 (st+1;zt+1;g) 19: ^at (st;zt;g) 20:qt rt+ Q'(st+1;^at+1;yt+1;g;) 21:4qt qt Q'(st;at;yt;g;) 22: end for 23:O'=1 TP t4qt@Q'(st;at;yt;g;) @' 24:O=1 TP t@Q'(st;^at;yt;g;) @a@^at @ 25: Update value function and policy with OandO' 26:end while F . Network Architecture A schematic illustrations of the policy and value networks are available in Figure 4. The inputs to the network consist of the current state stand previous action at 1, and the internal memory is updated incrementally at every step. Each network consists of a feedforward branch and recurrent branch, with the latter being tasked with inferring the dynamics from past observations. The internal memory is modeled using a layer of LSTM units and is provided only with information required to infer the dynamics (e.g. standat 1). The recurrent branch consists of an embedding layer of 128 fullyconnected units followed by 128 LSTM units. The goal g does not hold any information regarding the dynamics of the system, and is therefore processed only by the feedforward branch. Furthermore, since the current state stis of particular importance for determining the appropriate action for the current timestep, a copy is also provided as input to the feedforward branch. This presents subsequent layers with more direct access to the current state, without requiring information to Ô¨Ålter through the LSTM. The features computed by both branches are then concatenated and processed by 2 additional fully-connected layers of 128 units each. The value networkQ(st;at;at 1;g;)follows a similar architecture, with the query action atand parameters being processed by the feedforward branch. ReLU activations are used after Fig. 3. LSTM policy deployed on the Fetch arm. Bottom: The contact dynamics of the puck was modiÔ¨Åed by attaching a packet of chips to the bottom. each hidden layer (apart from the LSTM). The output layer ofQconsists of linear units, while consists of tanh output units scaled to span the bounds of each action parameter. V. EXPERIMENTS Results are best seen in the supplemental video https://youtu.be/XUW0cnvqbwM. Snapshots of policies deployed on the real robot are available in Figure 3. All simulations are performed using the MuJoCo physics engine  with a simulation timestep of 0.002s. 20 simulation timesteps are performed for every control timestep. Each episode consists of 100 control timestep, corresponding to approximately 4 seconds per episode, but may vary as a result of the random timesteps between actions. Table I details the range of values for each dynamics parameter. At the start of each episode, a new set of parameters is sampled by drawing values for each parameter from their respective range. Parameters such as mass, damping, friction, and controller gains are logarithmically sampled, while other parameters are uniformly sampled. The timestep 4tbetween actions varies every step according to 4t4t0+ Exp(), where4t0= 0:04sis the default control timestep, and Exp()is an exponential distribution with rate parameter . While4tvaries every timestep, is Ô¨Åxed within each Parameter Range Link Mass [0:25;4]default mass of each link Joint Damping [0:2;20]default damping of each joint Puck Mass [0:1;0:4]kg Puck Friction [0:1;5] Puck Damping [0:01;0:2]Ns=m Table Height [0:73;0:77]m Controller Gains [0:5;2]default gains Action Timestep  [125;1000]s 1 TABLE I DYNAMICS PARAMETERS AND THEIR RESPECTIVE RANGES .Fig. 4. Schematic illustrations of the policy network (top) , and value network (bottom) . Features that are relevant for inferring the dynamics of the environment are processed by the recurrent branch, while the other inputs are processed by the feedforward branch. episode. In addition to randomizing the physical properties of the simulated environment, we also simulate sensor noise by applying gaussian noise to the observed state features at every step. The noise has a mean of zero and a standard deviation of 5%of the running standard deviation of each feature. Gaussian action exploration noise is added at every step with a standard deviation of 0:01rad. The real puck has a mass of approximately 0:2kgand a radius of 0.065m. The goal is considered satisÔ¨Åed if the puck is within 0.07m of the target. The location of the puck is tracked using the PhaseSpace mocap system. When evaluating performance on the physical system, each episode Fig. 5. Joint trajectories recorded from the simulated and real robot when executing the same target trajectories. The joints correspond to the shoulder, elbow, and wrist of the Fetch arm.consists of 200 timesteps. Little calibration was performed to ensure that the behaviour of the simulation closely conforms to that of the real robot. While more extensive calibration will likely improve performance, we show that our policy is nonetheless able to adapt to the physical system despite poor calibration. To illustrate the discrepancies between the dynamics of the real world and simulation we executed the same target trajectory on the real and simulated robot, and recorded the resulting joint trajectories. Figure 5 illustrates the recorded trajectories. Given the same target trajectory, the pose trajectories of the simulated and real robot differ signiÔ¨Åcantly, with varying degrees of mismatch across joints. During training, parameter updates are performed using the ADAM optimizer  with a stepsize of 510 4for both the policy and value function. Updates are performed using batches of 128 episodes with 100 steps per episode. New goals are sampled using HER with a probability of k= 0:8. Each policy is trained for approximately 8000 update iterations using about 100 million samples, which requires approximately 8 hours to simulate on a 100 core cluster. A. Comparison of Architectures To evaluate the impact of different architectural choices, we compared policies modeled using different architectures and tested their performance in simulation and on the real robot. The Ô¨Årst is an LSTM policy following the architecture illustrated in Figure 4. Next we consider a memoryless feedforward network (FF) that receives only the current state stand goalgas input. As a baseline, we also trained a memoryless feedforward network without randomization (FF no Rand), then evaluated the performance with randomization. To provide the feedforward network with more information to infer the dynamics, we augmented the inputs with a history of the 8 previously observed states and actions (FF + Hist). The success rate is determined as the portion of episodes where the goal is fulÔ¨Ålled at the end of the episode. In simulation, performance of each policy is evaluated over 100 episodes, with randomized dynamics parameters for each episode. Learning curves comparing the performance of different model architectures in simulation are available in Figure 6. Four policies initialized with different random seeds are trained for each architecture. The LSTM learns faster while also converging to a higher success rate than Fig. 6. Learning curves of different network architectures. Four policies are trained for each architecture with different random seeds. Performance is evaluated over 100 episodes in simulation with random dynamics.Fig. 7. Performance of different models when deployed on the simulated and real robot for the pushing task. Policies are trained using only data from simulation. the feedforward models. The feedforward network trained without randomization is unable to cope with unfamiliar dynamics during evaluation. While training a memoryless policy with randomization improves robustness to random dynamics, it is still unable to perform the task consistently. Next, we evaluate the performance of the different models when deployed on the real Fetch arm. Figure 7 compares the performance of the Ô¨Ånal policies when deployed in simulation and the real world. Table II summarizes the performance of the models. The target and initial location of the puck is randomly placed within a 0:3m0:3m bound. While the performance of LSTM and FF + Hist policies are comparable in simulation, the LSTM is able to better generalize to the dynamics of the physical system. The feedforward network trained without randomization is unable to perform the task under the real world dynamics. B. Ablation To evaluate the effects of randomizing the various dynamics parameters, we trained policies with subsets of the parameters held Ô¨Åxed. A complete list of the dynamics parameters are available in Table I. The conÔ¨Ågurations we consider include training with a Ô¨Åxed timestep between actions, training without observation noise, or with Ô¨Åxed mass for each link. Table III summarizes the performance of the resulting policies when deployed on the real robot. Disabling randomization of the action timestep, observation noise, link mass, and friction impairs the policies‚Äô ability to adapt to the physical environment. Policies trained without randomizing the action timestep and observation noise show particularly noticeable drops in performance. This suggests that coping with the latency of the controller and sensor noise are important factors in adapting to the physical system. C. Robustness To evaluate the robustness of the LSTM policy to different dynamics when deployed on the real robot, we experimented with changing the contact dynamics of the physical system by attaching a packet of chips to the bottom of the puck. The texture of the bag reduces the friction between the puck and the table, while the contents of the bag further alters the contact dynamics. Nonetheless, the LSTM policy achieves a success rate of 0:910:04, which is comparable to the success rate without the attachment 0:890:06. The policyModel Success (Sim) Success (Real) Trials (Real) LSTM 0:910:03 0:890:06 28 FF no Rand 0:510:05 0:00:0 10 FF 0:830:04 0:670:14 12 FF + Hist 0:870:03 0:700:10 20 TABLE II PERFORMANCE OF THE POLICIES WHEN DEPLOYED ON THE SIMULATED AND REAL ROBOT . PERFORMANCE IN SIMULATION IS EVALUATED OVER 100 TRIALS WITH RANDOMIZED DYNAMICS PARAMETERS . Model Success Trials all 0:890:06 28 Ô¨Åxed action timestep 0:290:11 17 no observation noise 0:250:12 12 Ô¨Åxed link mass 0:640:10 22 Ô¨Åxed puck friction 0:480:10 27 TABLE III PERFORMANCE OF LSTM POLICIES ON THE REAL ROBOT ,WHERE THE POLICIES ARE TRAINED WITH SUBSETS OF PARAMETERS HELD FIXED . also develops clever strategies to make Ô¨Åne adjustments to position the puck over the target. One such strategy involves pressing on one side of the puck in order to partially upend it before sliding it to the target. Other strategies including manipulating the puck from the top or sides depending on the required adjustments, and correcting for case where the puck overshoots the target. These behaviours emerged naturally from the learning process using only a sparse binary reward. VI. C ONCLUSIONS We demonstrated the use of dynamics randomization to train recurrent policies that are capable of adapting to unfamiliar dynamics at runtime. Training policies with randomized dynamics in simulation enables the resulting policies to be deployed directly on a physical robot despite poor calibrations. By training exclusively in simulation, we are able to leverage simulators to generate a large volume of training data, thereby enabling us to use powerful RL techniques that are not yet feasible to apply directly on a physical system. Our experiments with a real world pushing tasks showed comparable performance to simulation and the ability to adapt to changes in contact dynamics. We also evaluated the importance of design decisions pertaining to choices of architecture and parameters which to randomize during training. We intend to extend this work to a richer repertoire tasks and incorporate more modalities such as vision. We hope this approach will open more opportunities for developing skillful agents in simulation that are then able to be deployed in the physical world. VII. A CKNOWLEDGEMENT We would like to thank Ankur Handa, Vikash Kumar, Bob McGrew, Matthias Plappert, Alex Ray, Jonas Schneider, and Peter Welinder for their support and feedback on this project. 