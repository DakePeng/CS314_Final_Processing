Gotta Learn Fast: A New Benchmark for Generalization in RL Alex Nichol, Vicki Pfau, Christopher Hesse, Oleg Klimov, John Schulman OpenAI {alex, vickipfau, csh, oleg, joschu }@openai.com Abstract In this report, we present a new reinforcement learning (RL) benchmark based on theSonic the HedgehogTMvideo game franchise. This benchmark is intended to measure the performance of transfer learning and few-shot learning algorithms in the RL domain. We also present and evaluate some baseline algorithms on the new benchmark. 1 Motivation In the past few years, it has become clear that deep reinforcement learning can solve diﬃcult, high-dimensional problems when given a good reward function and unlimited time to interact with the environment. However, while this kind of learning is a key aspect of intelligence, it is not the only one. Ideally, intelligent agents would also be able to generalize between tasks, using prior experience to pick up new skills more quickly. In this report, we introduce a new benchmark that we designed to make it easier for researchers to develop and test RL algorithms with this kind of capability. Most popular RL benchmarks such as the ALE  are not ideal for testing generalization between similar tasks. As a result, RL research tends to “train on the test set”, boasting an algorithm’s ﬁnal performance on the same environment(s) it was trained on. For the ﬁeld to advance towards algorithms with better generalization properties, we need RL benchmarks with proper splits between “train” and “test” environments, similar to supervised learning datasets. Our benchmark has such a split, making it ideal for measuring cross-task generalization. One interesting application of cross-task generalization is few-shot learning. Recently, supervised few-shot learning algorithms have improved by leaps and bounds –. This progress has hinged on the availability of good meta-learning datasets such as Omniglot  and Mini-ImageNet . Thus, if we want better few-shot RL algorithms, it makes sense to construct a similar kind of dataset for RL. Our benchmark is designed to be a meta-learning dataset, consisting of many similar tasks sampled from a single task distribution. Thus, it is a suitable test bed for few-shot RL algorithms. Beyond few-shot learning, there are many other applications of cross-task generalization that require the right kind of benchmark. For example, you might want an RL algorithm to learn how to explore in new environments. Our benchmark poses a fairly challenging exploration problem, and the train/test split presents a unique opportunity to learn how to explore on some levels and transfer this ability to other levels. 1 arXiv:1804.03720v2  [cs.LG]  23 Apr 20182 Related Work Our Gym Retro project, as detailed in Section 3.1, is related to both the Retro Learning Environment (RLE)  and the Arcade Learning Environment (ALE) . Unlike these projects, however, Gym Retro aims to be ﬂexible and easy to extend, making it straightforward to create a huge number of RL environments. Our benchmark is related to other meta-learning datasets like Omniglot  and MiniImageNet . In particular, our benchmark is intended to serve the same purpose for RL as datasets like Omniglot serve for supervised learning. Our baselines in Section 4 explore the ability of RL algorithms to transfer between video game environments. Several prior works have reported positive transfer results in the video game setting: •Parisotto et al.  observed that pre-training on certain Atari games could increase a network’s learning speed on other Atari games. •Rusu et al.  proposed a new architecture for transfer learning called progressive networks, and showed that it could boost learning speed across a variety of previously unseen Atari games. •Pathak et al.  found that an exploratory agent trained on one level of Super Mario Bros. could be used to boost performance on two other levels. •Fernando et al.  found that their PathNet algorithm increased learning speed on average when transferring from one Atari game to another. •Higgins et al.  used an unsupervised vision objective to produce robust features for a policy, and found that this policy was able to transfer to previously unseen vision tasks in DeepMind Lab  and MuJoCo . In previous literature on transfer learning in RL, there are two common evaluation techniques: evaluation on synthetic tasks, and evaluation on the ALE. The former evaluation technique is rather ad hoc and makes it hard to compare diﬀerent algorithms, while the latter typically reveals fairly small gains in sample complexity. One problem with the ALE in particular is that all the games are quite diﬀerent, meaning that it may not be possible to get large improvements from transfer learning. Ideally, further research in transfer learning would be able to leverage a standardized benchmark that is diﬃcult like the ALE but rich with similar environments like well-crafted synthetic tasks. We designed our proposed benchmark to satisfy both criteria. 3 The Sonic Benchmark This section describes the Sonic benchmark in detail. Each subsection focuses on a diﬀerent aspect of the benchmark, ranging from technical details to high-level design features. 23.1 Gym Retro Underlying the Sonic benchmark is Gym Retro, a project aimed at creating RL environments from various emulated video games. At the core of Gym Retro is the gym-retro Python package, which exposes emulated games as Gym  environments. Like RLE , gym-retro uses the libretro API1to interface with game emulators, making it very easy to add new emulators to gym-retro. The gym-retro package includes a dataset of games. Each game in the dataset consists of aROM , one or more save states , one or more scenarios , and a data ﬁle . Here are high-level descriptions of each of these components: •ROM – the data and code that make up a game; loaded by an emulator to play that game. •Save state – a snapshot of the console’s state at some point in the game. For example, a save state could be created for the beginning of each level. •Data ﬁle – a ﬁle describing where various pieces of information are stored in console memory. For example, a data ﬁle might indicate where the score is located. •Scenario – a description of done conditions and reward functions. A scenario ﬁle can reference ﬁelds from the data ﬁle. 3.2 The Sonic Video Game Figure 1: Screenshots from Sonic 3 & Knuckles .Left: a situation where the player can be shot into the air by utilizing an object with lever-like dynamics (Mushroom Hill Zone, Act 2). Middle: a door that opens when the player jumps on a button (Hydrocity Zone, Act 1). Right: a swing that the player must jump from at exactly the right time to reach a high platform (Mushroom Hill Zone, Act 2). In this benchmark, we use three similar games: Sonic The HedgehogTM,Sonic The HedgehogTM2, and Sonic 3 & Knuckles . All of these games have very similar rules and controls, although there are subtle diﬀerences between them (e.g. Sonic 3 & Knuckles includes some extra controls and characters). We use multiple games to get as many environments for our dataset as possible. 1https://www.libretro.com/index.php/api 3Each Sonic game is divided up into zones , and each zone is further divided up into acts. While the rules and overarching objective remain the same throughout the entire game, each zone has a unique set of textures and objects. Diﬀerent acts within a zone tend to share these textures and objects, but diﬀer in spatial layout. We will refer to a (ROM, zone, act) tuple as a “level”. The Sonic games provide a rich set of challenges for the player. For example, some zones include platforms that the player must jump on in order to open doors. Other zones require the player to ﬁrst jump on a lever to send a projectile into the air, then wait for the projectile to fall back on the lever to send the player over some sort of obstacle. One zone even has a swing that the player must jump oﬀ of at a precise time in order to launch Sonic up to a higher platform. Examples of these challenges are presented in Figure 1. 3.3 Games and Levels Our benchmark consists of a total of 58 save states taken from three diﬀerent games, where each of these save states has the player at the beginning of a diﬀerent level. A number of acts from the original games were not used because they contained only boss ﬁghts or because they were not compatible with our reward function. We split the test set by randomly choosing zones with more than one act and then randomly choosing an act from each selected zone. In this setup, the test set contains mostly objects and textures present in the training set, but with diﬀerent layouts. The test levels are listed in the following table: ROM Zone Act Sonic The Hedgehog SpringYardZone 1 Sonic The Hedgehog GreenHillZone 2 Sonic The Hedgehog StarLightZone 3 Sonic The Hedgehog ScrapBrainZone 1 Sonic The Hedgehog 2 MetropolisZone 3 Sonic The Hedgehog 2 HillTopZone 2 Sonic The Hedgehog 2 CasinoNightZone 2 Sonic 3 & Knuckles LavaReefZone 1 Sonic 3 & Knuckles FlyingBatteryZone 2 Sonic 3 & Knuckles HydrocityZone 1 Sonic 3 & Knuckles AngelIslandZone 2 3.4 Frame Skip The step() method on raw gym-retro environments progresses the game by roughly1 60thof a second. However, following common practice for ALE environments, we require the use of a frame skip  of 4. Thus, from here on out, we will use timesteps as the main unit of measuring in-game time. With a frame skip of 4, a timestep represents roughly1 15thof a second. We believe that this is more than enough temporal resolution to play Sonic well. Moreover, since deterministic environments are often susceptible to trivial scripted solutions , we require the use of a stochastic “sticky frame skip”. Sticky frame skip adds 4a small amount of randomness to the actions taken by the agent; it does not directly alter observations or rewards. Like standard frame skip, sticky frame skip applies nactions over 4 nframes. However, for each action, we delay it by one frame with probability 0 .25, applying the previous action for that frame instead. The following diagram shows an example of an action sequence with sticky frame skip: 3.5 Episode Boundaries Experience in the game is divided up into episodes, which roughly correspond to lives. At the end of each episode, the environment is reset to its original save state. Episodes can end on three conditions: •The player completes a level successfully. In this benchmark, completing a level corresponds to passing a certain horizontal oﬀset within the level. •The player loses a life. •4500 timesteps have elapsed in the current episode. This amounts to roughly 5 minutes of in-game time. The environment should only be reset if one of the aforementioned done conditions is met. Agents should not use special APIs to tell the environment to start a new episode early. Note that our benchmark omits the boss ﬁghts that often take place at the end of a level. For levels with boss ﬁghts, our done condition is deﬁned as a horizontal oﬀset that the agent must reach before the boss ﬁght. Although boss ﬁghts could be an interesting problem to solve, they are fairly diﬀerent from the rest of the game. Thus, we chose not to include them so that we could focus more on exploration, navigation, and speed. 3.6 Observations A gym-retro environment produces an observation at the beginning of every timestep. This observation is always a 24-bit RGB image, but the dimensions vary by game. For Sonic, the screen images are 320 pixels wide and 224 pixels tall. 3.7 Actions At every timestep, an agent produces an action representing a combination of buttons on the game console. Actions are encoded as binary vectors, where 1 means “pressed” and 0 means “not pressed”. For Sega Genesis games, the action space contains the following buttons: B, A, MODE, START, UP, DOWN, LEFT, RIGHT, C, Y, X, Z . 5A small subset of all possible button combinations makes sense in Sonic. In fact, there are only eight essential button combinations: {{},{LEFT},{RIGHT},{LEFT, DOWN}, {RIGHT, DOWN},{DOWN},{DOWN, B},{B}} The UPbutton is also useful on occasion, but for the most part it can be ignored. 3.8 Rewards During an episode, agents are rewarded such that the cumulative reward at any point in time is proportional to the horizontal oﬀset from the player’s initial position. Thus, going right always yields a positive reward, while going left always yields a negative reward. This reward function is consistent with our done condition, which is based on the horizontal oﬀset in the level. The reward consists of two components: a horizontal oﬀset, and a completion bonus. The horizontal oﬀset reward is normalized per level so that an agent’s total reward will be 9000 if it reaches the predeﬁned horizontal oﬀset that marks the end of the level. This way, it is easy to compare scores across levels of varying length. The completion bonus is 1000 for reaching the end of the level instantly, and drops linearly to zero at 4500 timesteps. This way, agents are encouraged to ﬁnish levels as fast as possible2. Since the reward function is dense, RL algorithms like PPO  and DQN  can easily make progress on new levels. However, the immediate rewards can be deceptive; it is often necessary to go backwards for prolonged amounts of time (Figure 2). In our RL baselines, we use reward preprocessing so that our agents are not punished for going backwards. Note, however, that the preprocessed reward still gives no information about when or how an agent should go backwards. 3.9 Evaluation In general, all benchmarks must provide some kind of performance metric. For Sonic, this metric takes the form of a “mean score” as measured across all the levels in the test set. Here are the general steps for evaluating an algorithm on Sonic: 1. At training time, use the training set as much or as little as you like. 2. At test time, play each test level for 1 million timesteps. Play each test level separately; do not allow information to ﬂow between test levels. Multiple copies of each environment may be used (as is done in algorithms like A3C ). 3. For each 1 million timestep evaluation, average the total reward per episode across all episodes. This gives a per-level mean score. 4. Average the mean scores for all the test levels, giving an aggregate metric of performance. 2In practice, RL agents may not be able to leverage a bonus at the end of an episode due to a discount factor. 6Figure 2: A trace of a successful path through the ﬁrst part of Labyrinth Zone, Act 2 inSonic The HedgehogTM. In the initial green segment, the agent is moving rightwards, getting positive reward. In the red segment, the agent must move to the left, getting negative reward. During the orange segment, the agent is once again moving right, but its cumulative reward is still not as high as it was after the initial green segment. In the ﬁnal green segment, the agent is ﬁnally improving its cumulative reward past the initial green segment. For an average player, it takes 20 to 30 seconds to get through the red and orange segments. The most important aspect of this procedure is the timestep limit for each test level. In the inﬁnite-timestep regime, there is no strong reason to believe that meta-learning or transfer learning is necessary. However, in the limited-timestep regime, transfer learning may be necessary to achieve good performance quickly. We aim for this version of the Sonic benchmark to be easier than zero-shot learning but harder than∞-shot learning. 1 million timesteps was chosen as the timestep limit because modern RL algorithms can make some progress in this amount of time. 4 Baselines In this section, we present several baseline learning algorithms and discuss their performance on the benchmark. Our baselines include human players, several methods that do not make use of the training set, and a simple transfer learning approach consisting of joint training followed by ﬁne tuning. Table 1 gives the aggregate scores for each of the baselines, and Figure 3 compares the baselines’ aggregate learning curves. 4.1 Humans For the human baseline, we had four test subjects play each test level for one hour. Before seeing the test levels, each subject had two hours to practice on the training levels. Table 7 in Appendix C shows average human scores over the course of an hour. 7Table 1: Aggregate test scores for each of the baseline algorithms. Algorithm Score Rainbow 2748.6±102.2 JERK 1904.0±21.9 PPO 1488.8±42.8 PPO (joint) 3127.9±116.9 Rainbow (joint) 2969.2±170.2 Human 7438.2±624.2 0.0 0.2 0.4 0.6 0.8 1.0 Timesteps (millions)1000200030004000500060007000Human Average Rainbow JERK PPO PPO (joint) Rainbow (joint) Figure 3: The mean learning curves for all the baselines across all the test levels. Every curve is an average over three runs. The y-axis represents instantaneous score, not average over training. 4.2 Rainbow Deep Q-learning (DQN)  is a popular class of algorithms for reinforcement learning in high-dimensional environments like video games. We use a speciﬁc variant of DQN, namely Rainbow , which performs particularly well on the ALE. We retain the architecture and most of the hyper-parameters from , with a few small changes. First, we set Vmax= 200 to account for Sonic’s reward scale. Second, we use a replay buﬀer size of 0.5M instead of 1M to lower the algorithm’s memory consumption. Third, we do not use hyper-parameter schedules; rather, we simply use the initial values of the schedules from . Since DQN tends to work best with a small, discrete action space, we use an action space containing seven actions: {{LEFT},{RIGHT},{LEFT, DOWN},{RIGHT, DOWN} {DOWN},{DOWN, B},{B}} We use an environment wrapper that rewards the agent based on deltas in the maximum 8x-position. This way, the agent is rewarded for getting further than it has been before (in the current episode), but it is not punished for backtracking in the level. This reward preprocessing gives a sizable performance boost. Table 2 in Appendix C shows Rainbow’s scores for each test level. 4.3 JERK: A Scripted Approach In this section, we present a simple algorithm that achieves high rewards on the benchmark without using any deep learning. This algorithm completely ignores observations and instead looks solely at rewards. We call this algorithm Just Enough Retained Knowledge (JERK). We note that JERK is loosely related to The Brute , a simple algorithm that ﬁnds good trajectories in deterministic Atari environments without leveraging any deep learning. Algorithm 1 in Appendix A describes JERK in detail. The main idea is to explore using a simple algorithm, then to replay the best action sequences more and more frequently as training progresses. Since the environment is stochastic, it is never clear which action sequence is the best to replay. Thus, each action sequence has a running mean of its rewards. Table 3 in Appendix C shows JERK’s scores for each test level. We note that JERK actually performs better than regular PPO, which is likely due to JERK’s perfect memory and its tailored exploration strategy. 4.4 PPO Proximal Policy Optimization (PPO)  is a policy gradient algorithm which performs well on the ALE. For this baseline, we run PPO individually on each of the test levels. For PPO we use the same action and observation spaces as for Rainbow, as well as the same reward preprocessing. For our experiments, we scaled the rewards by a small constant factor in order to bring the advantages to a suitable range for neural networks. This is similar to how we set Vmaxfor Rainbow. The CNN architecture is the same as the one used in  for Atari. We use the following hyper-parameters for PPO: Hyper-parameter Value Workers 1 Horizon 8192 Epochs 4 Minibatch size 8192 Discount (γ) 0.99 GAE parameter ( λ) 0.95 Clipping parameter ( /epsilon1)0.2 Entropy coeﬀ. 0.001 Reward scale 0.005 Table 4 in Appendix C shows PPO’s scores for each test level. 94.5 Joint PPO While Section 4.4 evaluates PPO with no meta-learning, this section explores the ability of PPO to transfer from the training levels to the test levels. To do this, we use a simple joint training algorithm3, wherein we train a policy on all the training levels and then use it as an initialization on the test levels. During meta-training, we train a single policy to play every level in the training set. Speciﬁcally, we run 188 parallel workers, each of which is assigned a level from the training set. At every gradient step, all the workers average their gradients together, ensuring that the policy is trained evenly across the entire training set. This training process requires hundreds of millions of timesteps to converge (see Figure 4), since the policy is being forced to learn a lot more than a single level. Besides the diﬀerent training setup, we use the same hyper-parameters as for regular PPO. Once the joint policy has been trained on all the training levels, we ﬁne-tune it on each test level under the standard evaluation rules. In essence, the training set provides an initialization that is plugged in when evaluating on the test set. Aside from the initialization, nothing is changed from the evaluation procedure used for Section 4.4. Figure 4 shows that, after roughly 50 million timesteps of joint training, further improvement on the training set stops leading to better performance on the test set. This can be thought of as the point where the model starts to overﬁt. The ﬁgure also shows that zero-shot performance does not increase much after the ﬁrst few million timesteps of joint training. 0 100 200 300 400 Timesteps ×106010002000300040005000Score Zero-shot, train Fine-tuning, average, test Fine-tuning, final, test Zero-shot, test Figure 4: Intermediate performance during the process of joint training a PPO model. The x-axis corresponds to timesteps into the joint training process. The zero-shot curves were densely sampled during training, while the ﬁne-tuning curves were sampled periodically. Table 5 in Appendix C shows Joint PPO’s scores for each test level. Table 9 in Appendix D shows Joint PPO’s ﬁnal scores for each training level. The resulting test performance is superior to that of Rainbow, and is roughly 100% better than that of regular PPO. Thus, it is clear that some kind of useful information is being transferred from the training levels to the test levels. 3We also tried a version of Reptile , but found that it yielded worse results. 104.6 Joint Rainbow Since Rainbow outperforms PPO with no joint training, it is natural to ask if Joint Rainbow analogously outperforms Joint PPO. Surprisingly, our experiments indicate that this is not the case. To train a single Rainbow model on the entire training set, we use a multi-machine training setup with 32 GPUs. Each GPU corresponds to a single worker , where each worker has its own replay buﬀer and eight environments. The environments are all “joint environments”, meaning that they sample a new training level at the beginning of every episode. Each worker runs the algorithm described in Algorithm 2 in Appendix A. Besides the unusual batch size and distributed worker setup, all the hyper-parameters are kept the same as for the regular Rainbow experiment. Table 6 in Appendix C shows the performance of ﬁne-tuning on every test level. Table 8 in Appendix D shows the performance of the jointly trained model on every training level. 5 Discussion We have presented a new reinforcement learning benchmark and used it to evaluate several baseline algorithms. Our results leave a lot of room for improvement, especially since our best transfer learning results are not much better than our best results learning from scratch. Also, our results are nowhere close to the maximum achievable score (which, by design, is somewhere between 9000 and 10000). Now that the benchmark and baseline results have been laid out, there are many directions to take further research. Here are some questions that future research might seek to answer: •How much can exploration objectives help training performance on the benchmark? •Can transfer learning be improved using data augmentation? •Is it possible to improve performance on the test set using a good feature representation learned on the training set (like in Higgins et al. )? •Can diﬀerent architectures (e.g. Transformers  and ResNets ) be used to improve training and/or test performance? While we believe the Sonic benchmark is a step in the right direction, it may not be suﬃcient for exploring meta-learning, transfer learning, and generalization in RL. Here are some possible problems with this benchmark, which will only be proven or disproven once more work has been done: •It may be possible to solve a Sonic level in many fewer than 1M timesteps without any transfer learning. •Sonic-speciﬁc hacks may outperform general meta-learning approaches. •Exploration strategies that work well in Sonic may not generalize beyond Sonic. 11•Mastering a Sonic level involves some degree of memorization. Algorithms which are good at few-shot memorization may not be good at other tasks. 